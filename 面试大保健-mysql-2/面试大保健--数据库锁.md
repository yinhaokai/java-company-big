本章的主要内容是数据库的锁，本章的前置篇章是 学习过了行，页的innodb的存储形式，学习了索引。

首先什么是数据库锁，在并发里面我们学习了什么是jvm的锁。这里要明确一点，锁是一个抽象的概念并非只存在于jvm里面，任何资源共享造成的冲突问题都会使用锁。

但是另一个方面，锁在分类上是通用的，都可以分为共享锁，排他锁。
对于mysql而言，锁有很多种分类

- 从锁的粒度分为 数据库锁，表锁，行锁；

- 行锁可以分为记录锁和间隙锁；
    
- 从锁的资源占有情况可以分为 共享锁S，排他锁X；

- 从sql操作而言 可以分为 读锁和写锁；

- 最后 间隙锁 + 行锁 构成了next-key锁

锁和事务的关系非常密切，事务的实现非常依赖于锁

因为我们平时用的都是innodb引擎，所以将对innodb相关的锁进行一个解析，其他引擎如果和innodb实现有比较大的差异的或者比较有意思的也会随手讲下。

innodb支持行锁和表锁
首先我们得明确哪些语句是加的行锁，然后我们得知道哪些是可以被显式调用的，最后我们看下行锁为什么能被加上，到底锁在哪里？

在介绍行锁的时候我们插入两个锁：

共享锁和排他锁，共享锁也就是s锁，排他锁x锁。
介绍下

第一
共享锁 共享锁之间不互斥，但是和排他锁是互斥的。
也就是说 我加了共享锁的行，我是无法加排他锁的

第二  
当前读都可以通过加锁的方式实现，比如共享读和排他读
对应的分别是 lock in share mode 和 for update，但是采用快照读和这些前面的都不会冲突，比如使用select *

第三

我们再反思下什么情况下会退化成表锁 update table set a=10 where b=10  ，答案是b的索引失效或者b没有索引。

行锁退化成表锁，所以大家一定要注意不要在没有索引的列作为条件上改数据，表锁带来很大性能上的损耗。因为update不同的行将会通过表锁锁住。

再衍生一点，如果是select * form table where b=10 会不会被锁住，答案是在默认隔离级别上不会，原因是我们有mvcc，所以读不会被锁住。加了索引以后，会不会被锁住，当然更不会被锁住啦。

衍生一点，排他读/共享读会不会被锁住。如果b列没有索引，会进入全表锁，无论哪种读都会被锁住，因为无论是排他读还是共享读都是当前读，只有快照读不会被锁。假设b列加了索引会不会被锁住，这里分两种情况，如果读的不是被锁住的那行，读都不会被阻塞。如果是读被update 锁住的那行的时候，无论哪种读都会被锁住。

第四 
一个事务里面，重复对一个行数据加锁，会阻塞吗。也就是两个update语句一模一样，会不会出现前一条update语句的锁被占用，后一条update拿不到锁导致事务等待。其实不会的这个锁在同一个事务里是可以被重入的。

那么，好的，我们通过了很简单的几个例子让我们搞清楚了 共享锁/排他锁  主要针对行锁 ，所以，可以被称为行共享锁，行排他锁。行排他锁是update语句自带的。当然行共享和行排他可以通过显式的方法区完成使用。

除了以上内容，我们再来回顾下事务等级。读已提交，可重复读和串行化。对于innodb引擎，他有更大的野心，那就是能否在不串行化的条件下完成串行化。

答案是可以的，通过我们的锁。这次我们的锁依旧属于行锁，只不过不同于之前的行锁，这个行锁锁的是记录。之前的行共享锁可以转换为记录共享锁，行排他锁可以转换为记录排他锁。我们这里可以被称之为间隙锁（gap）。

好，让我们通过innodb解决幻读的这个例子看下gap锁。

注意：
第一点，我们的gap或者是next-key和mvcc什么关系，mvcc关注的是快照读，而next-key是在当前读。因此没有半毛钱关系。

第二点，mvcc和幻读 ，next-key和幻读。这里有很多小伙伴傻傻搞不清，这里强调一下，mvcc 的快照读不能叫解决了幻读，即幻读本就不存在于mvcc，幻读只存在于当前读。因此mvcc不能叫解决幻读，因为update依赖会存在幻读问题，update是先读再写（注意），因此也会读，这个读是当前读，这个当前读不归mvcc负责。因此我们就这么理解 next-key就是解决幻读的。

说完这两点，就可以进入间隙锁的世界：
我们思考一个问题
如下语句

update table set a=10 where b=10;

假设b这一列是存在索引的，所以b=10的所有行会被锁住，等待修改。

但是，如果没有间隙锁的情况下，只有记录锁，可以被插入数据。
假设语句执行前有3条语句满足b=10.那么在被插入一条语句后，再次update的时候其实会有四条。这就破坏了原有的事务前后数据一致的语义。

好，我们得出了没有间隙锁的第一个问题，当前读会产生语义问题。

接着回顾以下之前我们提出的关于事务的流程，binlog 和 redolog会产生什么样的问题？


说了这么多，也就是说加入了间隙锁可以解决什么问题，那间隙锁到底是什么，我们来深层次了解以下。

首先说下，间隙锁什么时候有效
1.可重复读（RR）
2.必须有索引

第一点，没必要讲，即只有在rr级别下才有可能系统给你加间隙锁。
第二点，必须有索引。
第一个问题，为什么必须要有索引，没有索引会导致什么问题？

在上文我们提到，如果没有索引，行锁会退化成表锁。表锁就不管你是不是需要间隙锁了。

第二个问题
需要什么样的索引？
需要非主键索引，唯一索引。
为什么以上两个不需要，因为对于以上两个，都是唯一键。间隙锁是保证没有相同的插入，导致幻读。而唯一性则不具有插入相同数据的特性。

间隙锁，锁的是区间，假设现在的数据为
0 1 2 5 5 63
可产生的所有间隙锁为
（-∞-0） （0,1） （2,5） （5,63）
假设where 条件为 5  则向前，（2,5） 向后，（5,63） 都会被锁住。

如果是条件是 6，则锁住（5,63）

最后  
next-key 其实就是 gap+行锁 构成的前开后闭














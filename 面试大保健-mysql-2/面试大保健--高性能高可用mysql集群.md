大家好，我是大鱼哥。
今天我们来探讨一个问题，mysql是如何做分布式的？

首先需要了解 
1. mysql的主从同步如何实现的？
2. 主从的不一致问题以及对应解决方案？
2. 常见的主从备结构和双m结构？这些结构如何实现高可用？


本文的逻辑为：要实现分布式，首先得满足数据的传播，然后解决数据传播过程中会出现数据的不一致性问题，接着，如果出现单机故障该如何去做，最后这些问题都解决了，但是还是不行，那就需要从应用层面继续加大力度。

### 主从同步原理
之前在文章中介绍过binlog，不知道的同学可以往前面翻一翻。主从同步的核心机制就是需要基于binlog去实现。

下面一张是来自《MySQL实战45讲》中的一张图（侵删）

![image](C:/Users/Administrator/Desktop/a66c154c1bc51e071dd2cc8c1d6ca6a3.png)

这里说明下同步的核心逻辑
1. 从库和主库建立连接，从库向主库发送同步点位；
2. 主库收到从库的同步请求，从自己的binlog文件中读取到对应的同步点位及之后的数据发往从库；
3. 从库的io_thread负责和主库的dump_thread建立连接，并将数据写入到relay_log；
4. 从库的sql_thread从relay_log中读取数据并加载到自己的数据库中；


### 主从的不一致问题
上面一段已经让我们了解了怎样进行主从同步，那么主从同步会带来什么问题，如果从库只做异步的数据读取，没有延时要求这个时候是没有问题的。

但是从库有很大一部分场景就是用在读写分离上，既然用户已经将数据写入，但是此时去读的话，会读到空数据，显然这对某些业务来说是不能接受的。比如用户存入1000块钱，此时后端的构架是读写分离的，此时马上读到的数据其实是旧值。

说到这，很多小伙伴会问了，那我们如何解决读写分离的情况下带来的数据同步问题，即数据不一致性问题？

我这边给出三个常见的解决方案：

1.**对于某些强一致性情况，需要放弃从从库读，读写全部走主库**。带来的好处，确实可以实现主从的强一致性，坏处也显而易见，放弃了扩展性，读写分离等于白扯。

2.**从从库读的语句统一休息一下，等待主库的数据同步过来**。优点是，方案简单。缺点是：很难去衡量这个休息的时间，休息的时间长，读库的压力很大，休息的时间短，读到的依然是过期数据。

3.**通过某些手段去判断是否达到了一致**，只有达到了一致，从库的读请求才将被执行。当然这个一致还是短一致。因为在更新很快的场景下，会一致达不到执行条件。

4.**半同步复制semi-sync replication**，半同步复制是指通过将事务的commit延展到主从复制上来。流程为，主库把binlog发给从库；从库收到后，发送应答命令；主库收到命令后，将事务设为commit状态。这个的坏处是，只需要有一个从库给出ack命令，从库就会将事务设为commit状态，此时完成的快的从库可以满足主从一致，未完成的依然会读到过期，因此这个用在一主一从的环境里是比较理想的。

我们再回过头，我们一直都在致力于主从的数据完全同步再去进行查询。但是大鱼哥要和你说一句，其实不需要，只要达到某些条件，你在从库的查询就可以被默认为和主库的数据读到的数据是完全一致的。那么到底是什么条件呢，这里大鱼哥总结一下，主要有以下几种方案

1.等主库位点方案
2.GTID 方案


主从的不可能时时保持同步是肯定的，毕竟写入事务的时间都不同。所以略有延时的主从一致性是可以被接受的。但是主从不同步到了非常夸张的地步可能就是出现了一定的问题，这时候就应该注意了。那么什么情况下会导致主从的一致性非常糟糕。
大鱼哥总结成以下几点：

1.从库性能查
2.从库执行了乱七八糟的东西
3.有大事务在执行


### 如何实现高可用
既然是基于binlog实现，这里又可以产生几个问题，同步到一半，主机挂了怎么办？从机挂了怎么办？
先从从机挂了开始说起，在复制过程中从机挂掉了，（todo）起来以后从机怎么办，会不会存在数据丢失？

再将主机挂了，主机挂了，如果没有备机可能就得凉，所以在一般情况下，都会存在备机，备机的存在使得在发生主机挂掉的情况，备机能及时替换上来，这时候也会产生一个新的问题，如何找一个同步点。（todo）

